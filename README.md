# Микрофронтеды

## Введенние (1 слайд)

### Проблема, которую решают микрофронтеды (слайд 2)

Как все начинается и почему команды приходят к микрофронтендам?

Все начинается с монолита.
Вся кодовая база в одном месте, весь пользовательский интерфейс, бизнес логика и работа с базой данных находится в одном месте. Периодически возникают Good-классы, зачастую код сильно связанный, в связи с чем какие-то части трудно тестировать, а что-то протестировать вовсе нельзя, т.к слишком сложно/долго мокать данные.

На такой стадии новичку тяжело охватить проект мысленно, т.к много всего находится в одном месте, множество процессов приходится запомнить. А рядовым разработчикам приходится мириться  долгой сборкой и бороться с характерными для таких проектов проблемами, про которые я говорил ранее.

Конечно, с такой ситуацией можно жить, тем более, что просто взять и переписать все с нуля не представляется возможным, в связи с чем были придуманы следующие подходы (кстати, некоторые из них уже были успешно применены нами):

#### Слайд 3 Подходы

Итак, как решают возникшие проблемы:

- Для начала разделяем бек-енд и фронт-енд на 2-е независящих друг от друга части. Т.е в монолите создаем апи-контроллер, а на клиенте приложение эти данные получает и на их основании что-то рисует пользователю. Что мы с этого получаем?

    - Несомненные плюсы:
         - Пользовательский интерфейс теперь отделен от бекенда, клиенту нужно лишь запросить данные и нарисовать их,
         - При этом клиентский код тоже делится на модули, благодаря чему его проще развивать и поддерживать,
        - У каждого элемента на странице свой апи метод, благодаря чему проект проще осознать и в нем легче сориентироваться
    - Однако есть и минусы:
        - У нас все еще огромный бекенд с кучей источников данных,
        - Растет количество клиентских виджетов, из-за чего увеличивается время сборки,
        - Со временем клиентское приложение тоже становится таким себе монолитом, в котором тяжело разобраться.

Теперь у нас более прозрачное клиентское приложение, однако в бекенде все еще непросто разобраться, т.к его кодовая база не претерпела сильных изменений.

В связи с этим мы дробим апи методы на микросервисы, которые выносим куда-то отдельно от нашего монолита, у них появляется своя история развития, свой пайплан, в будущем, возможно, своя команда поддержки и развития.

Благодаря дроблению бекенда на микросервисы мы облегчаем кодовую базу монолита, чем упрощаем его поддержку, снижаем количество побочных эффектов, упрощаем рефакторинг и снижаем входной порог в проект.

Остается вопрос, а что делать с клиентским кодом и как не допустить разрастания монолита, несмотря на все предпринятые нами попытки по его укрощению?

Самый популярный и жизнеспособный ответ на сегодня: микрофронтенды.

### Что такое микрофронтеды (слайд 4)

Итак, что же такое микрофронтеды и чем они являются или могут являться?

#### Чем являются

Термин микрофронтенды стал популярным, потому что стали популярны микросервисы.
Разработчикам понравилась идея разбиения back-end монолита на небольшие, полностью автономные куски кода и они захотели привнести то же самое во front-end разработку.

Микрофронтенды могут быть как набором файлов и конфигурации, так и зависимостями, реализующими многократно используемый фрагмент кода, например:

- Компонент React, Vue, Angular
- Общая таблица стилей (например, CSS, SCSS),
- Клиентская библиотека или утилита,
- Миддлвары (любое промежуточное ПО), модули и провайдеры,
- Целая страница или простой UI элемент,
- Небольшая служебная функция или целый микросервис.

Все из этого может быть разного уровня сложности и конкретности, однако не стоит делать микрофронтенды слишком общими, чтобы не получить еще один монолит.

#### Цель применения (5 слайд)

Цель применения микрофронтендов состоит в том, чтобы рассматривать веб-сайт или веб-приложение как набор функций, принадлежащих независимым командам.

У каждой команды есть отдельная сфера бизнеса или миссия, на которой она специализируется. Команда кросс-функциональна и развивает свои функции от начала до конца, от базы данных до пользовательского интерфейса.

#### Ключевые идеи (6 слайд)

К ключевым идеям микрофронтендов можно отнести:

- Команды — агностики технологий. То есть каждая команда должна иметь возможность выбирать и обновлять свой стек без необходимости согласовывать действия с другими командами. Пользовательские элементы — отличный способ скрыть детали реализации, предоставляя другим пользователям нейтральный интерфейс.

- Код каждой команды изолирован. Не делитесь рантаймом, даже если все команды используют одну и ту же платформу. Создавайте независимые автономные приложения. Не полагайтесь на общее состояние или глобальные переменные.

- У каждой команды свой префикс. Согласуйте соглашения об именах там, где изоляция пока невозможна. CSS пространства имен, события, локальные хранилища и cookie, чтобы избежать коллизий

- Отдавайте предпочтение встроенным функциям браузера по сравнению с собственными API. Рекомендуется использовать события браузера для связи вместо создания глобальной системы издатель/подписчик. Если вам действительно нужно создать кросс-командный API, постарайтесь сделать его как можно проще.

- Ваша функция должна быть полезной, даже если JavaScript не удалось выполнить или еще не выполнен. Используйте универсальный рендеринг и прогрессивный рендеринг, чтобы улучшить воспринимаемую производительность.

#### Какие вообще проблемы решают?

Реализуемые таким образом, микрофронтенды предоставляют возможность разделения фронтенд-архитектуры на различные части для нескольких команд.
Каждая команда управляет сквозным жизненным циклом определенного микрофронтенда, доступного для индивидуальной разработки, создания версий, тестирования, визуализации, обновления и развертывания

## Варианты применения (7 слайд) (тут кратко)

Сейчас опишу кратко, затем отдельным слайдом подробнее расскажу про каждый способ

- Страницы и ссылки. Просто создаем html файлы, в которых оставляем ссылки на html файлы других команд.

- Iframes. Создаем iframe, который рендерит функционал, принадлежащий другой команде.

- Композиция с применением ajax. Делаем ajax запрос, на урл, полученный, например из data-аттрибута и отрисовываем результат запроса.

- Маршрутизация на стороне сервера. Создаем nginx-сервер, благодаря которому избавляемся от необходимости писать полный путь до компонентов. Т.е было `http://localhost:3002/team/module/component`, а стало `team/module/component`.

- Композиция на стороне сервера. Обычно выполняется сервисом, который находится между браузером и фактическими серверами с приложением. Самым большим преимущством данного метода является то, что страницу мы отдаем пользователю уже полностью собранную, в которую не нужно догружать компоненты. Это позволяет достичь отличной скорости отрисовки первого контента.

- shadow DOM. Теневой DOM – это способ создать свой, изолированный, DOM для компонента. Подключаем скрипт, предоставляемый другой командой, который в теневом DOM определяет «точку вставки» компонента.

### Вариант Страницы и ссылки. (8 слайд)

- Данный вариант хорошо подходит для тех случаев, когда компонент полностью изолирован и живет своей жизнью на отдельном урле, почти или совсем не пересекаясь с другим функционалом приложения

### Вариант Iframes. (9 слайд)

- Вариант с айфреймами обладает большим недостатком: если у нас все компоненты будут рендерится через iframe, то это будет съедать огромное количество памяти и страница будет жутко тормозить, но для каких-то очень точечных вещей вполне полезный подход.
- Айфреймы имеют свою реализацию взаимодействия на основе событий `postMessage()`, которая позволяет прокидывать в него данные, что делает этот подход вполне применимым при реализации микрофронтендов (но используется редко из-за очевидных минусов). Отдельно стоит отметить, что этот подход вообще никак не согласуется с SEO

### Вариант Композиция с применением ajax. (10 слайд)

- А сейчас в игру вступает Js. Команда А пишет код, который делает гет запрос на урл команды Б. Запрос возвращает нам заметку и мы вставляет её в свою страницу. Это неплохой вариант, особенно в связке со следующим, однако без JS страница не будет работать вообще.

### Вариант Маршрутизация на стороне сервера. (11 слайд)

- Этот вариант по сути улучшенная версия предыдущего. Теперь мы поднимаем web-server, в котором задаем урлы соответствующим командам (на картинке показано, как это примерно может выглядеть), куда команда будет ходить за компонентами. А дальше все то же самое — делаем get-запрос и вставляем разметку.
 В таком случае, только командам использующим компоненты другим команд нужно поменять урлы, остальным ничего делать не надо

### Вариант Композиция на стороне сервера. (12 слайд)

- Согласно тем отрытым источникам, которые попались мне на глаза при подготовке к этому докладу, данный метод наиболее часто (а может быть и всегда) реализуется при помощи директив Nginx Server Side Includes. Разработчики вставляют в нужном месте в коде директивы SSI *представлены в правой части слайда), которую nginx потом заменяет на уже готовую верстку. Помимо nginx есть и другие инструменты для реализации данного подхода, но дальше в докладе я их упоминать не буду, просто скажу, что они есть

### Вариант shadow DOM. (13 слайд)

После того, как мы вставили разметку в теневой DOM браузер выполняет «композицию»: берёт элементы из обычного DOM-дерева и отображает их в соответствующих элементах теневого DOM-дерева. В результате мы получаем именно то, что хотели – компонент, который можно наполнить данными. Чтобы отобразить содержимое, для каждого `<slot name="...">` в теневом DOM браузер ищет slot="..." с таким же именем в обычном DOM.

### Наилучший вариант (14 слайд)

С точки зрения производительности и надежности - это бесспорно Server Side Composition.

Т.к мы имеем дело с монолитом, нам полезно, что его можно использовать лишь частично, на слайде показано, как команда при помощи директив SSI оптимизировала критичные участки в разметке. Те места, что раньше подгружались аяксом, теперь приходят с сервера композиции целиком.

Но, теперь мы лучше контролируем все медленные места, эти места стали предсказуемее, задержка в получении данных минимальна, потому что речь идет не о загрузке контента клиентом, а об общении сервиса с сервисом.
В таком случае мы отвязываемся от скорости интернета наших клиентов, доставляем им контент так быстро, как только мы вообще способны.

### Варианты общения компонентов (15 слайд)

Актуальные на сегодняшний день варианты коммуникации компонентов

- Parent-Child Communication, это подход, при котором родитель получает возможность взаимодействовать с потомком. Т.е мы подключаем на страницу скрипт, предоставляемый другой командой, например `<script src="http://localhost:3002/static/fragment.js" async></script>`, в котором создается пользовательский HTML-элемент, способный принимать данные от родителя, благодаря механике custom elements.

- Child-Parent Communication реализуется по принципу кастомных событий, которые позволяют нам общаться с дочерними компонентами-предками других команд. Тем самым команды могут нативно реагировать на их изменения и обрабатывать это

- Fragment to Fragment Communication Суть та же, что и у подхода Child-Parent Communication, но в данном случае, события слушает не предок, а другой вложенный компонент, который как-то реагирует и обрабатывает эти события

### Какие вопросы может решить у нас (16 слайд)

Директивы SSI позволят оптимизировать критичные участки кода, которые в противном слаучае пользователю пришлось бы ждать с сервера. Благодаря этой технологии мы способны обеспечить максимально быструю отрисовку первого контента для пользователя, что всегда хорошо сказывается на UX и общих показателях сайта и конечно же получить все преимущества от повсеместного внедрения микрофронтендов

## Экосистема вокруг микрофронтендов (<https://bit.dev/> (17 слайд)

### Немного об экосистеме вокруг микрофронтендов

При активном внедрении микрофронтендов, довольно быстро их количество вырастает так сильно, что становится непросто найти тех, кто отвечает за тот или иной компонент.
В такой ситуации разработчики могут потерять уйму времени на межкомандное взаимодействие, тщетно стараясь найти мэйнтейнеров тех или иных компонентов.
Решить данную проблему взялись ребята из проекта <https://bit.dev/>.
Bit - это инструмент для составления приложений из независимых компонентов. Компонент может представлять собой композицию из множества других компонентов (допускается любой уровень конкретности), которые в конечном итоге составляют все приложение.
На скриношоте показано, что авторы предоставляют в конечном итоге как услугу. Все компоненты регистрируются в так называемом workspace, в котором затем создаются компоненты с указанным для каждого конкретного компонента пространством имен.
Можете посетить их сайт, у них прямо на главной есть демо, как это может выглядеть

## Судьба монолита (18 слайд)

Микрофронтенды не так просты и они конечно же имеют недостатки. Среди них часто неотвеченным остается, например, вопрос с общими стилями, иконками, критичными, для всего проекта целиком.
В мире микрофронтендов, если мы захотим поменять брендовый цвет с оранжевого на красный, то нам нужно будет попросить все команды поправить этот цвет у себя в компонентах, хотя подобная задача заняла бы от силы 20 минут в монолите.
Как бы мы не старались, но в конце-концов монолит никуда не денется и не стоит рассматривать микрофронтенды, как технологию, которая позволит навсегда отказаться от монолита. Нам по прежнему нужна единая точка входа на сайт, чтобы получать все необходимые стили для себя, например.
Мы так же никуда не денем большинство существующих обработчиков обмена данными.
Микрофронтенды в целом, про слабую связанность между собой, и раскрываются полностью лишь при грамотном планировании, в противном случае можно получить колизии имен в разметке (поскольку она общая для всех), проблему с роутингом (которую как раз позволяет решить монолит), проблемы с обновлением дизайна и т.п
Поэтому данную технологию на мой взгляд разумнее рассматривать с прицелом на будущее, вынося весь новый код в компоненты, а так же, при необходимости, выносить в них самый критичный функционал, который необходимо отрисовывать максимально быстро.

## Заключение (19 слайд)

-Микрофронтенды однозначное добро, необходимо лишь четкое понимание, чего именно мы хотим достичь и грамотно выбрать технологию

-Как бы там не было, серверная композиция лучше всего подходит нам, если мы хотим достичь настоящей выгоды от микрофронтендов

-Мы уже применяем микрофронтенды, осталось только улучшить подход (аякс стейты, ноде модули)

## Спасибо за внимание (20 слайд)

### Вопросы
